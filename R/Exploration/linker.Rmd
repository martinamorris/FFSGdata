---
title: "linker Report"
output:
  html_document:
    code_folding: hide
---

```{r, include= FALSE}
library(DataExplorer)
library(networkD3)
library(dplyr)
library(rlist)

path_to_src = here::here(file.path( 'Data'))
load(file=file.path(path_to_src,
                    "FinalClassification",
                    "full_classification.RData"))

load(file=file.path(path_to_src,
                    "FinalClassification",
                    "full_combined_harmonized.RData"))

load(file= file.path(path_to_src,
                     "HarmonizedFiles",
                     "HarmonizedDataSets.RData"))
```


## Overview

In this document, we will go through the outputs generated from `Linker.R`.
When running `Linker.R`, we get two outputs: classification and combined_harmonized.


### Combined harmonized outputs:

before going through combined_harmonized output, let'd first see the common columns to all 4 datasets:

Common columns :
```{r}
Reduce(intersect, list(colnames(kbp_harmonized),
                                     colnames(fe_harmonized),
                                     colnames(mpv_harmonized),
                                     colnames(wapo_harmonized)))
```



`Combined harmonized`is a dataframe in which each of the four harmonized dataset is stacked rowwise.

```{r}
str <- plot_str(combined_harmonized,
                print_network = FALSE)
diagonalNetwork(str)

```


### Classification outputs:

Classification is a list of 10 components, below is the components of this list:
```{r}
list.names(classification)
```

* *Data*: is the original data that we want to preform record linkage on
```{r}
str <- plot_str(classification$data,
                print_network = FALSE)
diagonalNetwork(str)
```

* *Pairs*: is a dataframe of all possible pairs in _data_.
Each row represents the comparison pattern of two records, identified by columns *id1* and *id2*. The other columns contain for each considered attribute a real number in the range [0..1] representing the degree of similarity. These columns are named according to the respective columns in data. The last column
contains the matching status of the pair, coded as 1 for a match or 0 for a non-match.
```{r}
str <- plot_str(classification$pairs,
                print_network = FALSE)
diagonalNetwork(str)

```


* *Frequencies*: the average frequency of values for each column included in pairs (reciprocal of number of distinct values).
```{r}
classification$frequencies
```

* *type*: to identify which process is done: 'deduplication' or 'linkage'
```{r}
classification$type
```

* *M*: the probabilty given the pair is a match. 
As the values were skewed, we had to log the y-axis.
```{r}

boxplot(log(classification$M))
plot(density(log(classification$M)))

```

* *U*: the probabilty given the pair is a nonmatch. 
As the values were skewed, we had to log the y-axis.
```{r}

boxplot(log(classification$U))
plot(density(log(classification$U)))

```


* *W*: is the weight for each pair. it is calculated using the function emWeights in the package recordLinkage.
W is the log of M divided by U.

```{r}
boxplot(classification$W)
plot(density(classification$W))
hist(classification$W, breaks = 400 )
```

* *Wdata*: Vector of log-likelihood weights as calculated by emWeights,
corresponding to the rows of pairs.

```{r}
plot(density(classification$Wdata))
hist(classification$Wdata, breaks = 50)
```


* *Prediction*: Linkage result. Coded as a factor with levels "N" for non-links, "P" for possible links and "L" for links.

```{r}
table(classification$prediction)
```






